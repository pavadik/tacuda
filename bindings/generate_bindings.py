#!/usr/bin/env python3
"""Generate language bindings for the tacuda C API.

This script parses ``include/tacuda.h`` and produces two artefacts:

* ``bindings/python/_generated.py`` - static description of the API used by
  the runtime Python wrappers.
* ``bindings/csharp/Tacuda.Generated.cs`` - P/Invoke declarations for the
  full API surface.

Both files are tracked in the repository and regenerated as part of CI to
ensure they stay in sync with the public header.
"""

from __future__ import annotations

import argparse
import dataclasses
import re
from pathlib import Path
from typing import Iterable, List, Optional, Sequence


ROOT = Path(__file__).resolve().parents[1]
HEADER = ROOT / "include" / "tacuda.h"
PYTHON_OUT = ROOT / "bindings" / "python" / "_generated.py"
CSHARP_OUT = ROOT / "bindings" / "csharp" / "Tacuda.Generated.cs"


@dataclasses.dataclass(frozen=True)
class Parameter:
    """Representation of a parameter in the ``tacuda`` C API."""

    name: str
    type_text: str
    base_type: str
    pointer: bool
    const: bool
    default: Optional[str] = None

    @property
    def is_stream(self) -> bool:
        return self.base_type == "cudaStream_t"


@dataclasses.dataclass(frozen=True)
class FunctionSpec:
    """Representation of a single exported API function."""

    c_name: str
    parameters: Sequence[Parameter]

    @property
    def py_name(self) -> str:
        if self.c_name.startswith("ct_"):
            return self.c_name[3:]
        return self.c_name

    @property
    def inputs(self) -> List[Parameter]:
        return [p for p in self.parameters if p.pointer and p.const]

    @property
    def outputs(self) -> List[Parameter]:
        return [p for p in self.parameters if p.pointer and not p.const]

    @property
    def size_param(self) -> Parameter:
        for param in self.parameters:
            if not param.pointer and param.name == "size":
                return param
        raise ValueError(f"Function {self.c_name} is missing a size parameter")

    @property
    def scalar_params(self) -> List[Parameter]:
        scalars: List[Parameter] = []
        for param in self.parameters:
            if param.pointer:
                continue
            if param.name == "size":
                continue
            scalars.append(param)
        return scalars


FUNC_PATTERN = re.compile(
    r"CTAPI_EXPORT\s+ctStatus_t\s+(ct_[a-zA-Z0-9_]+)\s*\((.*?)\)\s*;",
    re.DOTALL,
)


def _normalise_param(param: str) -> Parameter:
    original = param
    param = param.strip()
    if not param:
        raise ValueError("Empty parameter component in declaration")

    default: Optional[str] = None
    if "CTAPI_STREAM_DEFAULT" in param:
        param = param.replace("CTAPI_STREAM_DEFAULT", "").strip()
        default = "0"

    if "=" in param:
        param, default = [part.strip() for part in param.split("=", 1)]

    param = param.replace("*", " * ")
    param = re.sub(r"\s+", " ", param).strip()
    if " " not in param:
        raise ValueError(f"Unable to split parameter '{original}'")

    type_part, name = param.rsplit(" ", 1)
    pointer = "*" in type_part
    tokens = [t for t in type_part.replace("*", " ").split(" ") if t]
    const = "const" in tokens
    base_tokens = [t for t in tokens if t != "const"]
    if not base_tokens:
        raise ValueError(f"Could not determine base type for '{original}'")
    base_type = base_tokens[-1]

    return Parameter(
        name=name,
        type_text=type_part,
        base_type=base_type,
        pointer=pointer,
        const=const,
        default=default,
    )


def parse_header(text: str) -> List[FunctionSpec]:
    functions: List[FunctionSpec] = []
    for match in FUNC_PATTERN.finditer(text):
        name = match.group(1)
        params_blob = match.group(2)
        params_raw = [p.strip() for p in params_blob.split(",") if p.strip()]
        parameters = [_normalise_param(p) for p in params_raw]
        functions.append(FunctionSpec(c_name=name, parameters=parameters))
    return functions


def _format_python_tuple(items: Iterable[str]) -> str:
    items = list(items)
    if not items:
        return "()"
    if len(items) == 1:
        return f"({items[0]},)"
    return "(" + ", ".join(items) + ")"


def render_python(functions: Sequence[FunctionSpec]) -> str:
    lines: List[str] = []
    lines.append("# This file is auto-generated by bindings/generate_bindings.py.")
    lines.append("# Do not edit by hand.")
    lines.append("from __future__ import annotations")
    lines.append("")
    lines.append("from dataclasses import dataclass")
    lines.append("from typing import Tuple")
    lines.append("")
    lines.append("")
    lines.append("@dataclass(frozen=True)")
    lines.append("class ScalarParam:")
    lines.append("    name: str")
    lines.append("    ctype: str")
    lines.append("    default: str | None = None")
    lines.append("")
    lines.append("")
    lines.append("@dataclass(frozen=True)")
    lines.append("class FunctionSpec:")
    lines.append("    c_name: str")
    lines.append("    inputs: Tuple[str, ...]")
    lines.append("    outputs: Tuple[str, ...]")
    lines.append("    size_param: str")
    lines.append("    scalars: Tuple[ScalarParam, ...]")
    lines.append("")
    lines.append("")
    lines.append("FUNCTIONS = {")
    for func in functions:
        inputs = [f"\"{p.name}\"" for p in func.inputs]
        outputs = [f"\"{p.name}\"" for p in func.outputs]
        scalars: List[str] = []
        for param in func.scalar_params:
            default = param.default
            if default is None:
                scalars.append(
                    "            ScalarParam(name=\"%s\", ctype=\"%s\")," % (param.name, param.base_type)
                )
            else:
                scalars.append(
                    "            ScalarParam(name=\"%s\", ctype=\"%s\", default=\"%s\"),"
                    % (param.name, param.base_type, default)
                )

        lines.append(f"    \"{func.py_name}\": FunctionSpec(")
        lines.append(f"        c_name=\"{func.c_name}\",")
        lines.append(f"        inputs={_format_python_tuple(inputs)},")
        lines.append(f"        outputs={_format_python_tuple(outputs)},")
        lines.append(f"        size_param=\"{func.size_param.name}\",")
        if scalars:
            lines.append("        scalars=(")
            lines.extend(scalars)
            lines.append("        ),")
        else:
            lines.append("        scalars=(),")
        lines.append("    ),")
    lines.append("}")
    lines.append("")
    lines.append("__all__ = tuple(sorted(FUNCTIONS))")
    lines.append("")
    return "\n".join(lines) + "\n"


def _csharp_library_name_block() -> List[str]:
    return [
        "#if WINDOWS",
        'private const string LibraryName = "tacuda.dll";',
        "#elif OSX",
        'private const string LibraryName = "libtacuda.dylib";',
        "#else",
        'private const string LibraryName = "libtacuda.so";',
        "#endif",
    ]


def _csharp_type(param: Parameter) -> str:
    if param.pointer:
        # All pointer parameters in the public API are ``float *``.
        return "float[]"

    mapping = {
        "int": "int",
        "float": "float",
        "ctMaType_t": "int",
        "cudaStream_t": "IntPtr",
    }
    try:
        return mapping[param.base_type]
    except KeyError as exc:
        raise KeyError(f"Unsupported scalar type '{param.base_type}' for parameter '{param.name}'") from exc


def render_csharp(functions: Sequence[FunctionSpec]) -> str:
    lines: List[str] = []
    lines.append("// <auto-generated>")
    lines.append("// This file was generated by bindings/generate_bindings.py.")
    lines.append("// Do not edit manually.")
    lines.append("// </auto-generated>")
    lines.append("using System;")
    lines.append("using System.Runtime.InteropServices;")
    lines.append("")
    lines.append("namespace Tacuda.Bindings;")
    lines.append("")
    lines.append("internal static partial class NativeMethods")
    lines.append("{")
    for line in _csharp_library_name_block():
        if line.startswith("#"):
            lines.append(line)
        else:
            lines.append("    " + line)
    lines.append("")

    for func in functions:
        parameters = []
        for param in func.parameters:
            csharp_type = _csharp_type(param)
            if param.is_stream:
                parameters.append(f"{csharp_type} {param.name} = default")
            else:
                parameters.append(f"{csharp_type} {param.name}")
        params_joined = ", ".join(parameters)
        lines.append("    [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]")
        lines.append(
            f"    internal static extern int {func.c_name}({params_joined});"
        )
        lines.append("")

    lines.append("}")
    lines.append("")
    return "\n".join(lines) + "\n"


def write_if_different(path: Path, content: str) -> bool:
    if path.exists() and path.read_text(encoding="utf-8") == content:
        return False
    path.write_text(content, encoding="utf-8")
    return True


def main() -> int:
    parser = argparse.ArgumentParser(description="Generate bindings from tacuda.h")
    parser.add_argument("--check", action="store_true", help="verify files are up to date")
    args = parser.parse_args()

    header_text = HEADER.read_text(encoding="utf-8")
    functions = parse_header(header_text)

    python_content = render_python(functions)
    csharp_content = render_csharp(functions)

    if args.check:
        stale = []
        try:
            existing_python = PYTHON_OUT.read_text(encoding="utf-8")
        except FileNotFoundError:
            stale.append(str(PYTHON_OUT.relative_to(ROOT)))
        else:
            if existing_python != python_content:
                stale.append(str(PYTHON_OUT.relative_to(ROOT)))

        try:
            existing_csharp = CSHARP_OUT.read_text(encoding="utf-8")
        except FileNotFoundError:
            stale.append(str(CSHARP_OUT.relative_to(ROOT)))
        else:
            if existing_csharp != csharp_content:
                stale.append(str(CSHARP_OUT.relative_to(ROOT)))
        if stale:
            print("The following generated files are out of date:")
            for path in stale:
                print(f"  {path}")
            print("Run bindings/generate_bindings.py to update them.")
            return 1
        return 0

    changed = write_if_different(PYTHON_OUT, python_content)
    changed |= write_if_different(CSHARP_OUT, csharp_content)
    if changed:
        print("Bindings updated.")
    else:
        print("Bindings already up to date.")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
